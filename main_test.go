// * generated by claude sonnet 4.5
package goSqlite

import (
	"database/sql"
	"os"
	"path/filepath"
	"testing"

	"github.com/pardnchiu/go-sqlite/core"
)

func setupTestDB(t *testing.T) (*core.Connector, *sql.DB, string) {
	t.Helper()

	dbPath := filepath.Join(t.TempDir(), "test.db")
	name := "test_" + t.Name()
	database, err := New(core.Config{
		Key:      name,
		Path:     dbPath,
		Lifetime: 30,
	})
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}

	db, err := database.DB(name)
	if err != nil {
		t.Fatalf("failed to get db instance: %v", err)
	}

	return database, db.Raw(), dbPath
}

func TestNew(t *testing.T) {
	t.Run("create new database", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "test.db")
		database, err := New(core.Config{
			Key:      "test_new",
			Path:     dbPath,
			Lifetime: 30,
		})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if database == nil {
			t.Fatal("expected database instance, got nil")
		}

		db, err := database.DB("test_new")
		if err != nil {
			t.Fatalf("failed to get db instance: %v", err)
		}
		if db == nil {
			t.Fatal("expected db instance, got nil")
		}
		defer database.Close()

		if _, err := os.Stat(dbPath); os.IsNotExist(err) {
			t.Fatalf("database file not created at %s", dbPath)
		}
	})

	t.Run("reuse existing database connection", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "test.db")
		config := core.Config{
			Key:      "test_reuse",
			Path:     dbPath,
			Lifetime: 30,
		}

		database1, err := New(config)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer database1.Close()

		db1, err := database1.DB("test_reuse")
		if err != nil {
			t.Fatalf("failed to get database1 instance: %v", err)
		}

		database2, err := New(config)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		db2, err := database2.DB("test_reuse")
		if err != nil {
			t.Fatalf("failed to get database2 instance: %v", err)
		}

		if db1.Raw() != db2.Raw() {
			t.Error("expected same db instance for same key")
		}
	})

	t.Run("auto generate key from path", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "mydb.db")
		database, err := New(core.Config{
			Path:     dbPath,
			Lifetime: 30,
		})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer database.Close()

		db, err := database.DB("mydb")
		if err != nil {
			t.Fatalf("failed to get database2 instance: %v", err)
		}

		if db == nil {
			t.Fatal("expected db instance, got nil")
		}
	})

	t.Run("invalid path", func(t *testing.T) {
		database, err := New(core.Config{
			Key:  "test_invalid",
			Path: "/invalid/path/db.db",
		})
		if err == nil {
			if database != nil {
				database.Close()
			}
			t.Fatal("expected error for invalid path")
		}
		if database != nil {
			t.Error("expected nil database on error")
		}
	})
}

func TestDatabaseClose(t *testing.T) {
	t.Run("close database successfully", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		database.Close()

		if database.Map != nil {
			t.Error("expected db map to be nil after close")
		}
	})

	t.Run("close multiple databases", func(t *testing.T) {
		dbPath1 := filepath.Join(t.TempDir(), "test1.db")
		dbPath2 := filepath.Join(t.TempDir(), "test2.db")

		database, err := New(core.Config{Key: "db1", Path: dbPath1})
		if err != nil {
			t.Fatalf("failed to create db1: %v", err)
		}

		_, err = New(core.Config{Key: "db2", Path: dbPath2})
		if err != nil {
			t.Fatalf("failed to create db2: %v", err)
		}

		database.Close()

		if database.Map != nil {
			t.Error("expected db map to be nil after close")
		}
	})
}

func TestBuilderCreate(t *testing.T) {
	t.Run("create table with basic columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{
					Name:         "id",
					Type:         "INTEGER",
					IsPrimary:    true,
					AutoIncrease: true,
				},
				core.Column{
					Name:       "name",
					Type:       "TEXT",
					IsNullable: false,
				},
			)

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		var tableName string
		err = db.QueryRow("SELECT name FROM sqlite_master WHERE type='table' AND name='users'").Scan(&tableName)
		if err != nil {
			t.Fatalf("table not created: %v", err)
		}
		if tableName != "users" {
			t.Errorf("expected table name 'users', got %s", tableName)
		}
	})

	t.Run("create table with all column types", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("products").
			Create(
				core.Column{
					Name:         "id",
					Type:         "INTEGER",
					IsPrimary:    true,
					AutoIncrease: true,
				},
				core.Column{
					Name:       "name",
					Type:       "TEXT",
					IsNullable: false,
					IsUnique:   true,
				},
				core.Column{
					Name:    "price",
					Type:    "REAL",
					Default: 0.0,
				},
				core.Column{
					Name:       "description",
					Type:       "TEXT",
					IsNullable: true,
				},
			)

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
	})

	t.Run("create table without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Create(
				core.Column{Name: "id", Type: "INTEGER"},
			)

		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("create table without columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("empty").
			Create()

		if err == nil {
			t.Fatal("expected error for empty columns")
		}
	})
}

func TestBuilderInsert(t *testing.T) {
	t.Run("insert single row", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT", IsNullable: false},
				core.Column{Name: "email", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Insert(map[string]any{
				"name":  "test",
				"email": "test@example.com",
			})

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		var count int
		err = db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count)
		if err != nil {
			t.Fatalf("failed to count rows: %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1 row, got %d", count)
		}
	})

	t.Run("insert without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Insert(map[string]any{"name": "test"})

		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("insert with empty data", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("users").
			Insert(map[string]any{})

		if err == nil {
			t.Fatal("expected error for empty data")
		}
	})
}

func TestBuilderInsertReturningID(t *testing.T) {
	t.Run("insert and return id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		id, err := core.NewBuilder(db).
			Table("users").
			InsertReturningID(map[string]any{
				"name": "test",
			})

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})

	t.Run("insert multiple rows and check incrementing id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		id1, _ := core.NewBuilder(db).Table("users").InsertReturningID(map[string]any{"name": "user1"})
		id2, _ := core.NewBuilder(db).Table("users").InsertReturningID(map[string]any{"name": "user2"})

		if id2 != id1+1 {
			t.Errorf("expected id2 to be %d, got %d", id1+1, id2)
		}
	})

	t.Run("insert returning id with error", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("nonexistent").
			InsertReturningID(map[string]any{"name": "test"})

		if err == nil {
			t.Fatal("expected error for nonexistent table")
		}
	})
}

func TestBuilderSelect(t *testing.T) {
	t.Run("select columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Select("id", "name", "email")

		if len(builder.SelectList) != 3 {
			t.Errorf("expected 3 columns, got %d", len(builder.SelectList))
		}
		if builder.SelectList[0] != "id" {
			t.Errorf("expected first column 'id', got %s", builder.SelectList[0])
		}
	})

	t.Run("select all columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Select("*")

		if len(builder.SelectList) != 1 || builder.SelectList[0] != "*" {
			t.Error("expected single '*' column")
		}
	})
}

func TestBuilderWhere(t *testing.T) {
	t.Run("single where condition", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Where("id = ?", 1)

		if len(builder.WhereList) != 1 {
			t.Errorf("expected 1 where condition, got %d", len(builder.WhereList))
		}
		if builder.WhereList[0].Condition != "id = ?" {
			t.Errorf("expected condition 'id = ?', got %s", builder.WhereList[0].Condition)
		}
		if builder.WhereList[0].Operator != "AND" {
			t.Errorf("expected operator 'AND', got %s", builder.WhereList[0].Operator)
		}
		if len(builder.WhereArgs) != 1 || builder.WhereArgs[0] != 1 {
			t.Error("expected where args [1]")
		}
	})

	t.Run("multiple where conditions", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Where("id = ?", 1).
			Where("status = ?", "active")

		if len(builder.WhereList) != 2 {
			t.Errorf("expected 2 where conditions, got %d", len(builder.WhereList))
		}
		if len(builder.WhereArgs) != 2 {
			t.Errorf("expected 2 where args, got %d", len(builder.WhereArgs))
		}
	})
}

func TestBuilderOrWhere(t *testing.T) {
	t.Run("or where condition", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Where("id = ?", 1).
			OrWhere("id = ?", 2)

		if len(builder.WhereList) != 2 {
			t.Errorf("expected 2 where conditions, got %d", len(builder.WhereList))
		}
		if builder.WhereList[1].Operator != "OR" {
			t.Errorf("expected operator 'OR', got %s", builder.WhereList[1].Operator)
		}
	})
}

func TestBuilderJoin(t *testing.T) {
	t.Run("inner join", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Join("orders", "users.id = orders.user_id")

		if len(builder.JoinList) != 1 {
			t.Errorf("expected 1 join, got %d", len(builder.JoinList))
		}
		if builder.JoinList[0].Mode != "INNER JOIN" {
			t.Errorf("expected 'INNER JOIN', got %s", builder.JoinList[0].Mode)
		}
		if builder.JoinList[0].Table != "orders" {
			t.Errorf("expected table 'orders', got %s", builder.JoinList[0].Table)
		}
		if builder.JoinList[0].On != "users.id = orders.user_id" {
			t.Errorf("expected on clause, got %s", builder.JoinList[0].On)
		}
	})

	t.Run("multiple joins", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Join("orders", "users.id = orders.user_id").
			Join("products", "orders.product_id = products.id")

		if len(builder.JoinList) != 2 {
			t.Errorf("expected 2 joins, got %d", len(builder.JoinList))
		}
	})
}

func TestBuilderLeftJoin(t *testing.T) {
	t.Run("left join", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			LeftJoin("orders", "users.id = orders.user_id")

		if len(builder.JoinList) != 1 {
			t.Errorf("expected 1 join, got %d", len(builder.JoinList))
		}
		if builder.JoinList[0].Mode != "LEFT JOIN" {
			t.Errorf("expected 'LEFT JOIN', got %s", builder.JoinList[0].Mode)
		}
	})
}

func TestInsertConflict(t *testing.T) {
	t.Run("insert or ignore", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "email", Type: "TEXT", IsNullable: false, IsUnique: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			InsertConflict(core.Ignore, map[string]any{"email": "test@example.com"})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		// Insert duplicate - should be ignored
		_, err = core.NewBuilder(db).
			Table("users").
			InsertConflict(core.Ignore, map[string]any{"email": "test@example.com"})
		if err != nil {
			t.Fatalf("expected no error for ignored conflict, got %v", err)
		}

		var count int
		_ = db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count)
		if count != 1 {
			t.Errorf("expected 1 row, got %d", count)
		}
	})

	t.Run("insert or replace", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").InsertConflict(core.Replace, map[string]any{"id": 1, "name": "original"})
		_, _ = core.NewBuilder(db).Table("users").InsertConflict(core.Replace, map[string]any{"id": 1, "name": "replaced"})

		var name string
		_ = db.QueryRow("SELECT name FROM users WHERE id = 1").Scan(&name)
		if name != "replaced" {
			t.Errorf("expected 'replaced', got %s", name)
		}
	})

	t.Run("insert or abort", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").InsertConflict(core.Abort, map[string]any{"id": 1})
		_, err = core.NewBuilder(db).Table("users").InsertConflict(core.Abort, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for abort on conflict")
		}
	})

	t.Run("insert or fail", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").InsertConflict(core.Fail, map[string]any{"id": 1})
		_, err = core.NewBuilder(db).Table("users").InsertConflict(core.Fail, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for fail on conflict")
		}
	})

	t.Run("insert or rollback", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").InsertConflict(core.Rollback, map[string]any{"id": 1})
		_, err = core.NewBuilder(db).Table("users").InsertConflict(core.Rollback, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for rollback on conflict")
		}
	})

	t.Run("insert conflict without table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			InsertConflict(core.Ignore, map[string]any{"name": "test"})
		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})
}

func TestInsertConflictReturningID(t *testing.T) {
	t.Run("insert conflict returning id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		id, err := core.NewBuilder(db).
			Table("users").
			InsertConflictReturningID(core.Ignore, map[string]any{"name": "test"})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})

	t.Run("insert conflict returning id with error", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("nonexistent").
			InsertConflictReturningID(core.Ignore, map[string]any{"name": "test"})
		if err == nil {
			t.Fatal("expected error for nonexistent table")
		}
	})
}

func TestInsertOnConflictDoUpdate(t *testing.T) {
	t.Run("on conflict do update", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := db.Exec(`CREATE TABLE users (
			id INTEGER PRIMARY KEY,
			email TEXT UNIQUE,
			name TEXT
		)`)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		// Insert initial row
		_, _ = core.NewBuilder(db).Table("users").Insert(
			map[string]any{"id": 1, "email": "test@example.com", "name": "original"},
		)

		// Insert with ON CONFLICT DO UPDATE
		_, err = core.NewBuilder(db).Table("users").Insert(
			map[string]any{"id": 1, "email": "test@example.com", "name": "should_be_ignored"},
			map[string]any{"name": "updated"},
		)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		var name string
		_ = db.QueryRow("SELECT name FROM users WHERE id = 1").Scan(&name)
		if name != "updated" {
			t.Errorf("expected 'updated', got %s", name)
		}
	})
}

func TestValidateColumn(t *testing.T) {
	t.Run("valid column names", func(t *testing.T) {
		validNames := []string{"id", "user_name", "Column1", "_private", "a", "A"}
		for _, name := range validNames {
			if err := core.ValidateColumn(name); err != nil {
				t.Errorf("expected %q to be valid, got error: %v", name, err)
			}
		}
	})

	t.Run("invalid column names", func(t *testing.T) {
		invalidNames := []string{"1invalid", "has space", "has-dash", "has.dot", "", "日本語"}
		for _, name := range invalidNames {
			if err := core.ValidateColumn(name); err == nil {
				t.Errorf("expected %q to be invalid", name)
			}
		}
	})
}

func TestFormatValue(t *testing.T) {
	tests := []struct {
		input    any
		expected string
	}{
		{"hello", "'hello'"},
		{123, "123"},
		{int64(456), "456"},
		{3.14, "3.14"},
		{true, "true"},
		{false, "false"},
		{[]byte("bytes"), "'[98 121 116 101 115]'"},
		{struct{ Name string }{"test"}, "'{test}'"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			result := core.FormatValue(tt.input)
			if result != tt.expected {
				t.Errorf("core.FormatValue(%v) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestInsertWithInvalidColumn(t *testing.T) {
	t.Run("insert with invalid column name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Insert(map[string]any{"invalid-column": "test"})
		if err == nil {
			t.Fatal("expected error for invalid column name")
		}
	})

	t.Run("insert with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("invalid-table").
			Insert(map[string]any{"name": "test"})
		if err == nil {
			t.Fatal("expected error for invalid table name")
		}
	})
}

func TestCreateWithInvalidColumn(t *testing.T) {
	t.Run("create table with invalid column name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "invalid-name", Type: "INTEGER"},
			)
		if err == nil {
			t.Fatal("expected error for invalid column name")
		}
	})
}

func TestCreateWithForeignKey(t *testing.T) {
	t.Run("create table with foreign key", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create users table: %v", err)
		}

		err = core.NewBuilder(db).
			Table("orders").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{
					Name: "user_id",
					Type: "INTEGER",
					ForeignKey: &core.Foreign{
						Table:  "users",
						Column: "id",
					},
				},
			)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
	})
}

func TestCreateWithDefaultString(t *testing.T) {
	t.Run("create table with string default", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "status", Type: "TEXT", Default: "active"},
			)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
	})
}

func TestInsertNoData(t *testing.T) {
	t.Run("insert with no data arguments", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("users").
			Insert()
		if err == nil {
			t.Fatal("expected error for no data")
		}
	})
}

func TestInsertOnConflictWithInvalidUpdateColumn(t *testing.T) {
	t.Run("on conflict update with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := db.Exec(`CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)`)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(
			map[string]any{"id": 1, "name": "test"},
			map[string]any{"invalid-column": "value"},
		)
		if err == nil {
			t.Fatal("expected error for invalid column in conflict update")
		}
	})
}

func TestBuilderOrderBy(t *testing.T) {
	t.Run("order by default ASC", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrderBy("name", core.Asc)

		if len(builder.OrderByList) != 1 {
			t.Errorf("expected 1 order by clause, got %d", len(builder.OrderByList))
		}
		if builder.OrderByList[0] != `"name" ASC` {
			t.Errorf("expected '\"name\" ASC', got %s", builder.OrderByList[0])
		}
	})

	t.Run("order by DESC", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrderBy("created_at", core.Desc)

		if builder.OrderByList[0] != `"created_at" DESC` {
			t.Errorf("expected '\"created_at\" DESC', got %s", builder.OrderByList[0])
		}
	})

	t.Run("multiple order by", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrderBy("name", core.Asc).
			OrderBy("id", core.Desc)

		if len(builder.OrderByList) != 2 {
			t.Errorf("expected 2 order by clauses, got %d", len(builder.OrderByList))
		}
	})
}

func TestBuilderLimit(t *testing.T) {
	t.Run("limit with single argument", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Limit(10)

		if builder.WithLimit == nil || *builder.WithLimit != 10 {
			t.Error("expected limit 10")
		}
		if builder.WithOffset != nil {
			t.Error("expected offset to be nil")
		}
	})

	t.Run("limit with two arguments (offset, limit)", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Limit(5, 10)

		if builder.WithOffset == nil || *builder.WithOffset != 5 {
			t.Error("expected offset 5")
		}
		if builder.WithLimit == nil || *builder.WithLimit != 10 {
			t.Error("expected limit 10")
		}
	})

	t.Run("limit with no arguments", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Limit()

		if builder.WithLimit != nil {
			t.Error("expected limit to be nil")
		}
	})
}

func TestBuilderOffset(t *testing.T) {
	t.Run("offset", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Offset(20)

		if builder.WithOffset == nil || *builder.WithOffset != 20 {
			t.Error("expected offset 20")
		}
	})
}

func TestBuilderGet(t *testing.T) {
	t.Run("get all rows", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT", IsNullable: false},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice", "age": 30})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob", "age": 25})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("id", "name", "age").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var count int
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 rows, got %d", count)
		}
	})

	t.Run("get with where clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			Where("name = ?", "Alice").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var name string
		if rows.Next() {
			_ = rows.Scan(&name)
		}
		if name != "Alice" {
			t.Errorf("expected 'Alice', got %s", name)
		}
	})

	t.Run("get with order by and limit", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			OrderBy("name", core.Asc).
			Limit(2).
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var names []string
		for rows.Next() {
			var name string
			_ = rows.Scan(&name)
			names = append(names, name)
		}
		if len(names) != 2 {
			t.Errorf("expected 2 rows, got %d", len(names))
		}
		if names[0] != "Alice" {
			t.Errorf("expected first name 'Alice', got %s", names[0])
		}
	})

	t.Run("get with offset", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "A"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "B"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "C"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			OrderBy("name", core.Asc).
			Limit(1).
			Offset(1).
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var name string
		if rows.Next() {
			_ = rows.Scan(&name)
		}
		if name != "B" {
			t.Errorf("expected 'B', got %s", name)
		}
	})

	t.Run("get with join", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, _ = db.Exec(`CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)`)
		_, _ = db.Exec(`CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, amount REAL)`)
		_, _ = db.Exec(`INSERT INTO users (id, name) VALUES (1, 'Alice')`)
		_, _ = db.Exec(`INSERT INTO orders (id, user_id, amount) VALUES (1, 1, 100.50)`)

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("*").
			Join("orders", "users.id = orders.user_id").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		if !rows.Next() {
			t.Error("expected at least one row from join")
		}
	})

	t.Run("get with or where", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			Where("name = ?", "Alice").
			OrWhere("name = ?", "Charlie").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var count int
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 rows, got %d", count)
		}
	})

	t.Run("get without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Select("name").
			Get()
		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("get with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("invalid-table").
			Get()
		if err == nil {
			t.Fatal("expected error for invalid table name")
		}
	})

	t.Run("get with invalid column name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Select("invalid-column").
			Get()
		if err == nil {
			t.Fatal("expected error for invalid column name")
		}
	})

	t.Run("get with select star only", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Test"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		if !rows.Next() {
			t.Error("expected at least one row")
		}
	})
}

func TestBuilderFirst(t *testing.T) {
	t.Run("first returns single row", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		row, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			OrderBy("name", core.Asc).
			First()
		if err != nil {
			t.Fatalf("First() failed: %v", err)
		}

		var name string
		err = row.Scan(&name)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if name != "Alice" {
			t.Errorf("expected 'Alice', got %s", name)
		}
	})

	t.Run("first with where clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		row, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			Where("name = ?", "Bob").
			First()
		if err != nil {
			t.Fatalf("First() failed: %v", err)
		}

		var name string
		err = row.Scan(&name)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if name != "Bob" {
			t.Errorf("expected 'Bob', got %s", name)
		}
	})

	t.Run("first with no select columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Test"})

		row, err := core.NewBuilder(db).
			Table("users").
			First()
		if err != nil {
			t.Fatalf("First() failed: %v", err)
		}

		var id int
		var name string
		err = row.Scan(&id, &name)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if name != "Test" {
			t.Errorf("expected 'Test', got %s", name)
		}
	})
}

func TestBuilderCount(t *testing.T) {
	t.Run("count all rows", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		count, err := core.NewBuilder(db).
			Table("users").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 3 {
			t.Errorf("expected 3, got %d", count)
		}
	})

	t.Run("count with where clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "status", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "active"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "active"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "inactive"})

		count, err := core.NewBuilder(db).
			Table("users").
			Where("status = ?", "active").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("count without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).Count()
		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("count empty table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		count, err := core.NewBuilder(db).
			Table("users").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 0 {
			t.Errorf("expected 0, got %d", count)
		}
	})
}

func TestBuilderTotal(t *testing.T) {
	t.Run("get with total", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("id", "name").
			Total().
			Limit(2).
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var count int
		for rows.Next() {
			var total, id int
			var name string
			err := rows.Scan(&total, &id, &name)
			if err != nil {
				t.Fatalf("scan error: %v", err)
			}
			if total != 3 {
				t.Errorf("expected total 3, got %d", total)
			}
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 rows returned, got %d", count)
		}
	})

	t.Run("total returns builder", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			Total()

		if !builder.WithTotal {
			t.Error("expected withTotal to be true")
		}
	})
}

func TestWhereHelpers(t *testing.T) {
	t.Run("WhereEq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			WhereEq("name", "Alice").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var name string
		if rows.Next() {
			_ = rows.Scan(&name)
		}
		if name != "Alice" {
			t.Errorf("expected 'Alice', got %s", name)
		}
	})

	t.Run("WhereEq with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereEq("invalid-column", "value")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereNotEq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})

		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			WhereNotEq("name", "Alice").
			Get()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		var name string
		if rows.Next() {
			_ = rows.Scan(&name)
		}
		if name != "Bob" {
			t.Errorf("expected 'Bob', got %s", name)
		}
	})

	t.Run("WhereNotEq with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereNotEq("invalid-column", "value")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereGt", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 20})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 30})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereGt("age", 25).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereGt with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereGt("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereLt", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 20})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 30})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereLt("age", 25).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereLt with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereLt("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereGe", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 20})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 30})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereGe("age", 25).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("WhereGe with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereGe("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereLe", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 20})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 30})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereLe("age", 25).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("WhereLe with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereLe("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereIn", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereIn("name", []any{"Alice", "Charlie"}).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("WhereIn with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereIn("invalid-column", []any{"a", "b"})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereIn with empty values", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereIn("name", []any{})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for empty values")
		}
	})

	t.Run("WhereNotIn", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereNotIn("name", []any{"Alice", "Charlie"}).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereNotIn with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereNotIn("invalid-column", []any{"a", "b"})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereNotIn with empty values", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereNotIn("name", []any{})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for empty values")
		}
	})

	t.Run("WhereNull", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "email", Type: "TEXT", IsNullable: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = db.Exec("INSERT INTO users (email) VALUES (NULL)")
		_, _ = db.Exec("INSERT INTO users (email) VALUES ('test@example.com')")

		count, err := core.NewBuilder(db).
			Table("users").
			WhereNull("email").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereNull with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereNull("invalid-column")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereNotNull", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "email", Type: "TEXT", IsNullable: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = db.Exec("INSERT INTO users (email) VALUES (NULL)")
		_, _ = db.Exec("INSERT INTO users (email) VALUES ('test@example.com')")

		count, err := core.NewBuilder(db).
			Table("users").
			WhereNotNull("email").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereNotNull with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereNotNull("invalid-column")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("WhereBetween", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 15})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 35})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereBetween("age", 20, 30).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1, got %d", count)
		}
	})

	t.Run("WhereBetween with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			WhereBetween("invalid-column", 10, 20)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})
}

func TestOrWhereHelpers(t *testing.T) {
	t.Run("OrWhereEq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Bob"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "Charlie"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereEq("name", "Alice").
			OrWhereEq("name", "Bob").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereEq with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereEq("invalid-column", "value")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereNotEq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "status", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "active"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "pending"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "inactive"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereEq("status", "active").
			OrWhereNotEq("status", "inactive").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereNotEq with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereNotEq("invalid-column", "value")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereGt", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 15})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 35})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereLt("age", 20).
			OrWhereGt("age", 30).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereGt with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereGt("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereLt", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 15})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 35})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereGt("age", 30).
			OrWhereLt("age", 20).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereLt with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereLt("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereGe", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 15})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 35})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereLt("age", 20).
			OrWhereGe("age", 35).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereGe with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereGe("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereLe", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 15})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 35})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereGt("age", 30).
			OrWhereLe("age", 15).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereLe with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereLe("invalid-column", 10)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereIn", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "status", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "active"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "pending"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "inactive"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereEq("status", "active").
			OrWhereIn("status", []any{"pending", "inactive"}).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 3 {
			t.Errorf("expected 3, got %d", count)
		}
	})

	t.Run("OrWhereIn with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereIn("invalid-column", []any{"a", "b"})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereIn with empty values", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereIn("status", []any{})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for empty values")
		}
	})

	t.Run("OrWhereNotIn", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "status", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "active"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "pending"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"status": "inactive"})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereEq("status", "active").
			OrWhereNotIn("status", []any{"active", "pending"}).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereNotIn with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereNotIn("invalid-column", []any{"a", "b"})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereNotIn with empty values", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereNotIn("status", []any{})

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for empty values")
		}
	})

	t.Run("OrWhereNull", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "email", Type: "TEXT", IsNullable: true},
				core.Column{Name: "phone", Type: "TEXT", IsNullable: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES ('a@a.com', NULL)")
		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES (NULL, '123')")
		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES ('b@b.com', '456')")

		count, err := core.NewBuilder(db).
			Table("users").
			WhereNull("email").
			OrWhereNull("phone").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereNull with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereNull("invalid-column")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereNotNull", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "email", Type: "TEXT", IsNullable: true},
				core.Column{Name: "phone", Type: "TEXT", IsNullable: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES ('a@a.com', NULL)")
		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES (NULL, '123')")
		_, _ = db.Exec("INSERT INTO users (email, phone) VALUES (NULL, NULL)")

		count, err := core.NewBuilder(db).
			Table("users").
			WhereNotNull("email").
			OrWhereNotNull("phone").
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereNotNull with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereNotNull("invalid-column")

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})

	t.Run("OrWhereBetween", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 10})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 40})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"age": 55})

		count, err := core.NewBuilder(db).
			Table("users").
			WhereBetween("age", 20, 30).
			OrWhereBetween("age", 50, 60).
			Count()
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 2 {
			t.Errorf("expected 2, got %d", count)
		}
	})

	t.Run("OrWhereBetween with invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).
			Table("users").
			OrWhereBetween("invalid-column", 10, 20)

		if len(builder.WhereList) != 0 {
			t.Error("expected no where clause for invalid column")
		}
	})
}

func TestDatabaseDB(t *testing.T) {
	t.Run("get builder from existing db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		builder, err := database.DB("test_" + t.Name())
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if builder == nil {
			t.Fatal("expected builder, got nil")
		}
	})

	t.Run("get builder from non-existent db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		_, err := database.DB("non_existent_key")
		if err == nil {
			t.Fatal("expected error for non-existent db")
		}
	})
}

func TestDatabaseQuery(t *testing.T) {
	t.Run("query existing db", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice"})

		rows, err := database.Query("test_"+t.Name(), "SELECT * FROM users")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		if !rows.Next() {
			t.Fatal("expected at least one row")
		}
	})

	t.Run("query non-existent db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		_, err := database.Query("non_existent_key", "SELECT 1")
		if err == nil {
			t.Fatal("expected error for non-existent db")
		}
	})
}

func TestDatabaseQueryContext(t *testing.T) {
	t.Run("query with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1})

		ctx := t.Context()
		rows, err := database.QueryContext(ctx, "test_"+t.Name(), "SELECT * FROM users")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		if !rows.Next() {
			t.Fatal("expected at least one row")
		}
	})

	t.Run("query context non-existent db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := database.QueryContext(ctx, "non_existent_key", "SELECT 1")
		if err == nil {
			t.Fatal("expected error for non-existent db")
		}
	})
}

func TestDatabaseExec(t *testing.T) {
	t.Run("exec on existing db", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		result, err := database.Exec("test_"+t.Name(), "INSERT INTO users (id) VALUES (?)", 1)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		affected, _ := result.RowsAffected()
		if affected != 1 {
			t.Errorf("expected 1 row affected, got %d", affected)
		}
	})

	t.Run("exec on non-existent db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		_, err := database.Exec("non_existent_key", "SELECT 1")
		if err == nil {
			t.Fatal("expected error for non-existent db")
		}
	})
}

func TestDatabaseExecContext(t *testing.T) {
	t.Run("exec with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		result, err := database.ExecContext(ctx, "test_"+t.Name(), "INSERT INTO users (id) VALUES (?)", 1)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		affected, _ := result.RowsAffected()
		if affected != 1 {
			t.Errorf("expected 1 row affected, got %d", affected)
		}
	})

	t.Run("exec context non-existent db", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := database.ExecContext(ctx, "non_existent_key", "SELECT 1")
		if err == nil {
			t.Fatal("expected error for non-existent db")
		}
	})
}

func TestGetContext(t *testing.T) {
	t.Run("get with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 2, "name": "Bob"})

		ctx := t.Context()
		rows, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			GetContext(ctx)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 rows, got %d", count)
		}
	})
}

func TestFirstContext(t *testing.T) {
	t.Run("first with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice"})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 2, "name": "Bob"})

		ctx := t.Context()
		row, err := core.NewBuilder(db).
			Table("users").
			Select("name").
			OrderBy("name", core.Asc).
			FirstContext(ctx)
		if err != nil {
			t.Fatalf("FirstContext() failed: %v", err)
		}

		var name string
		err = row.Scan(&name)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if name != "Alice" {
			t.Errorf("expected 'Alice', got %s", name)
		}
	})
}

func TestCountContext(t *testing.T) {
	t.Run("count with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 2})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 3})

		ctx := t.Context()
		count, err := core.NewBuilder(db).
			Table("users").
			CountContext(ctx)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if count != 3 {
			t.Errorf("expected 3, got %d", count)
		}
	})
}

func TestInsertContext(t *testing.T) {
	t.Run("insert with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		_, err = core.NewBuilder(db).
			Table("users").
			InsertContext(ctx, map[string]any{"id": 1, "name": "Alice"})
		if err != nil {
			t.Fatalf("InsertContext() failed: %v", err)
		}

		count, _ := core.NewBuilder(db).Table("users").Count()
		if count != 1 {
			t.Errorf("expected 1 row, got %d", count)
		}
	})

	t.Run("insert context no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			InsertContext(ctx, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestInsertContextReturningID(t *testing.T) {
	t.Run("insert context returning id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		id, err := core.NewBuilder(db).
			Table("users").
			InsertContextReturningID(ctx, map[string]any{"id": 1, "name": "Alice"})
		if err != nil {
			t.Fatalf("InsertContextReturningID() failed: %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})

	t.Run("insert context returning id no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			InsertContextReturningID(ctx, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestInsertContexConflict(t *testing.T) {
	t.Run("insert context conflict ignore", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		_, err = core.NewBuilder(db).
			Table("users").
			InsertContexConflict(ctx, core.Ignore, map[string]any{"id": 1, "name": "Alice"})
		if err != nil {
			t.Fatalf("InsertContexConflict() failed: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			InsertContexConflict(ctx, core.Ignore, map[string]any{"id": 1, "name": "Bob"})
		if err != nil {
			t.Fatalf("InsertContexConflict() with duplicate should not fail with Ignore: %v", err)
		}

		count, _ := core.NewBuilder(db).Table("users").Count()
		if count != 1 {
			t.Errorf("expected 1 row after conflict ignore, got %d", count)
		}
	})

	t.Run("insert context conflict no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			InsertContexConflict(ctx, core.Ignore, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestInsertContextConflictReturningID(t *testing.T) {
	t.Run("insert context conflict returning id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		id, err := core.NewBuilder(db).
			Table("users").
			InsertContextConflictReturningID(ctx, core.Replace, map[string]any{"id": 1, "name": "Alice"})
		if err != nil {
			t.Fatalf("InsertContextConflictReturningID() failed: %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})

	t.Run("insert context conflict returning id no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			InsertContextConflictReturningID(ctx, core.Replace, map[string]any{"id": 1})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestUpdate(t *testing.T) {
	t.Run("update single row", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
				core.Column{Name: "age", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice", "age": 25})
		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 2, "name": "Bob", "age": 30})

		affected, err := core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Update(map[string]any{"name": "Alicia", "age": 26})
		if err != nil {
			t.Fatalf("Update() failed: %v", err)
		}

		if affected != 1 {
			t.Errorf("expected 1 affected row, got %d", affected)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("name", "age").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var name string
		var age int
		rows.Scan(&name, &age)
		if name != "Alicia" || age != 26 {
			t.Errorf("expected (Alicia, 26), got (%s, %d)", name, age)
		}
	})

	t.Run("update no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Update(map[string]any{"name": "Test"})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})

	t.Run("update no data", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Update(map[string]any{})
		if err == nil {
			t.Fatal("expected error for no data")
		}
	})

	t.Run("update invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Update(map[string]any{"invalid;column": "value"})
		if err == nil {
			t.Fatal("expected error for invalid column name")
		}
	})
}

func TestUpdateContext(t *testing.T) {
	t.Run("update with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice"})

		ctx := t.Context()
		affected, err := core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			UpdateContext(ctx, map[string]any{"name": "Alicia"})
		if err != nil {
			t.Fatalf("UpdateContext() failed: %v", err)
		}

		if affected != 1 {
			t.Errorf("expected 1 affected row, got %d", affected)
		}
	})

	t.Run("update context no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			UpdateContext(ctx, map[string]any{"name": "Test"})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestIncrease(t *testing.T) {
	t.Run("increase default value", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "count": 10})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Increase("count").
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Increase() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("count").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var count int
		rows.Scan(&count)
		if count != 11 {
			t.Errorf("expected 11, got %d", count)
		}
	})

	t.Run("increase custom value", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "count": 10})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Increase("count", 5).
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Increase() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("count").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var count int
		rows.Scan(&count)
		if count != 15 {
			t.Errorf("expected 15, got %d", count)
		}
	})

	t.Run("increase invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "count": 10})

		builder := core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Increase("invalid;column")
		if builder == nil {
			t.Fatal("expected builder to be returned even with invalid column")
		}
	})
}

func TestDecrease(t *testing.T) {
	t.Run("decrease default value", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "count": 10})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Decrease("count").
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Decrease() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("count").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var count int
		rows.Scan(&count)
		if count != 9 {
			t.Errorf("expected 9, got %d", count)
		}
	})

	t.Run("decrease custom value", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "count": 10})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Decrease("count", 3).
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Decrease() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("count").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var count int
		rows.Scan(&count)
		if count != 7 {
			t.Errorf("expected 7, got %d", count)
		}
	})

	t.Run("decrease invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		builder := core.NewBuilder(db).
			Table("users").
			Decrease("invalid;column")
		if builder == nil {
			t.Fatal("expected builder to be returned even with invalid column")
		}
	})
}

func TestToggle(t *testing.T) {
	t.Run("toggle boolean value", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "active", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "active": 1})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Toggle("active").
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Toggle() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("active").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var active int
		rows.Scan(&active)
		if active != 0 {
			t.Errorf("expected 0 after toggle, got %d", active)
		}
	})

	t.Run("toggle false to true", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "active", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "active": 0})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Toggle("active").
			Update(map[string]any{})
		if err != nil {
			t.Fatalf("Toggle() failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("active").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var active int
		rows.Scan(&active)
		if active != 1 {
			t.Errorf("expected 1 after toggle, got %d", active)
		}
	})

	t.Run("toggle invalid column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		builder := core.NewBuilder(db).
			Table("users").
			Toggle("invalid;column")
		if builder == nil {
			t.Fatal("expected builder to be returned even with invalid column")
		}
	})
}

func TestUpdateWithIncreaseAndData(t *testing.T) {
	t.Run("update with both increase and data", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).
			Table("users").
			Create(
				core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
				core.Column{Name: "name", Type: "TEXT"},
				core.Column{Name: "count", Type: "INTEGER"},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, _ = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "Alice", "count": 10})

		_, err = core.NewBuilder(db).
			Table("users").
			WhereEq("id", 1).
			Increase("count", 5).
			Update(map[string]any{"name": "Alicia"})
		if err != nil {
			t.Fatalf("Update() with Increase failed: %v", err)
		}

		rows, _ := core.NewBuilder(db).Table("users").Select("name", "count").WhereEq("id", 1).Get()
		defer rows.Close()
		rows.Next()
		var name string
		var count int
		rows.Scan(&name, &count)
		if name != "Alicia" || count != 15 {
			t.Errorf("expected (Alicia, 15), got (%s, %d)", name, count)
		}
	})
}

func TestUpdateInvalidTable(t *testing.T) {
	t.Run("update with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Table("invalid;table").
			Update(map[string]any{"name": "Test"})
		if err == nil {
			t.Fatal("expected error for invalid table name")
		}
	})
}

func TestGetContextError(t *testing.T) {
	t.Run("get context no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			Select("id").
			GetContext(ctx)
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestFirstError(t *testing.T) {
	t.Run("first no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).
			Select("id").
			First()
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestFirstContextError(t *testing.T) {
	t.Run("first context no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).
			Select("id").
			FirstContext(ctx)
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestDelete(t *testing.T) {
	t.Run("delete with where clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user1"})
		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user2"})
		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user3"})

		affected, err := core.NewBuilder(db).Table("users").WhereEq("name", "user2").Delete()
		if err != nil {
			t.Fatalf("delete failed: %v", err)
		}
		if affected != 1 {
			t.Errorf("expected 1 row affected, got %d", affected)
		}

		var count int
		db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count)
		if count != 2 {
			t.Errorf("expected 2 remaining rows, got %d", count)
		}
	})

	t.Run("delete without where requires force", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Delete()
		if err == nil {
			t.Fatal("expected error when deleting without where and force")
		}
	})

	t.Run("delete with force=true", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user1"})
		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user2"})

		affected, err := core.NewBuilder(db).Table("users").Delete(true)
		if err != nil {
			t.Fatalf("delete with force failed: %v", err)
		}
		if affected != 2 {
			t.Errorf("expected 2 rows affected, got %d", affected)
		}
	})

	t.Run("delete without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).WhereEq("id", 1).Delete()
		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("delete with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).Table("invalid;table").WhereEq("id", 1).Delete()
		if err == nil {
			t.Fatal("expected error for invalid table name")
		}
	})

	t.Run("delete with join not supported", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Join("orders", "users.id = orders.user_id").
			WhereEq("id", 1).
			Delete()
		if err == nil {
			t.Fatal("expected error for delete with join")
		}
	})

	t.Run("delete multiple with where", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
			core.Column{Name: "status", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "a", "status": "inactive"})
		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "b", "status": "inactive"})
		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "c", "status": "active"})

		affected, err := core.NewBuilder(db).
			Table("users").
			WhereEq("status", "inactive").
			Delete()
		if err != nil {
			t.Fatalf("delete multiple failed: %v", err)
		}
		if affected != 2 {
			t.Errorf("expected 2 rows affected, got %d", affected)
		}
	})
}

func TestConflictChained(t *testing.T) {
	t.Run("insert with conflict ignore chained", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			core.Column{Name: "name", Type: "TEXT", IsUnique: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "test"})
		if err != nil {
			t.Fatalf("first insert failed: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Conflict(core.Ignore).Insert(map[string]any{"id": 2, "name": "test"})
		if err != nil {
			t.Fatalf("conflict ignore should not error: %v", err)
		}
	})

	t.Run("insert with conflict replace", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			core.Column{Name: "name", Type: "TEXT", IsUnique: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "test"})
		if err != nil {
			t.Fatalf("first insert failed: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Conflict(core.Replace).Insert(map[string]any{"id": 2, "name": "test"})
		if err != nil {
			t.Fatalf("conflict replace failed: %v", err)
		}

		var id int
		db.QueryRow("SELECT id FROM users WHERE name = 'test'").Scan(&id)
		if id != 2 {
			t.Errorf("expected id 2 after replace, got %d", id)
		}
	})

	t.Run("insert with conflict abort", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			core.Column{Name: "name", Type: "TEXT", IsUnique: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "test"})
		if err != nil {
			t.Fatalf("first insert failed: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Conflict(core.Abort).Insert(map[string]any{"id": 2, "name": "test"})
		if err == nil {
			t.Fatal("conflict abort should error on duplicate")
		}
	})

	t.Run("insert with conflict fail", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			core.Column{Name: "name", Type: "TEXT", IsUnique: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "test"})
		if err != nil {
			t.Fatalf("first insert failed: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Conflict(core.Fail).Insert(map[string]any{"id": 2, "name": "test"})
		if err == nil {
			t.Fatal("conflict fail should error on duplicate")
		}
	})

	t.Run("insert with conflict rollback", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
			core.Column{Name: "name", Type: "TEXT", IsUnique: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{"id": 1, "name": "test"})
		if err != nil {
			t.Fatalf("first insert failed: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").Conflict(core.Rollback).Insert(map[string]any{"id": 2, "name": "test"})
		if err == nil {
			t.Fatal("conflict rollback should error on duplicate")
		}
	})
}

func TestGroupBy(t *testing.T) {
	t.Run("group by single column", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("orders").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "category", Type: "TEXT"},
			core.Column{Name: "amount", Type: "INTEGER"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 100})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 200})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "B", "amount": 150})

		rows, err := db.Query("SELECT category, SUM(amount) as total FROM orders GROUP BY category")
		if err != nil {
			t.Fatalf("group by query failed: %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 grouped rows, got %d", count)
		}

		builder := core.NewBuilder(db).Table("orders").GroupBy("category")
		if len(builder.GroupByList) != 1 || builder.GroupByList[0] != "category" {
			t.Error("expected groupBy to contain 'category'")
		}
	})

	t.Run("group by multiple columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("sales").GroupBy("region", "product")
		if len(builder.GroupByList) != 2 {
			t.Errorf("expected 2 columns in groupBy, got %d", len(builder.GroupByList))
		}
	})

	t.Run("group by with empty columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").GroupBy()
		if len(builder.GroupByList) != 0 {
			t.Error("expected empty groupBy for empty columns")
		}
	})

	t.Run("group by with invalid column skipped", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").GroupBy("valid", "invalid;column", "another")
		if len(builder.GroupByList) != 2 {
			t.Errorf("expected 2 valid columns in groupBy, got %d", len(builder.GroupByList))
		}
	})

	t.Run("group by builds correct SQL", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("orders").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "category", Type: "TEXT"},
			core.Column{Name: "amount", Type: "INTEGER"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 100})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 200})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "B", "amount": 150})

		rows, err := core.NewBuilder(db).
			Table("orders").
			Select("category").
			GroupBy("category").
			Get()
		if err != nil {
			t.Fatalf("group by with builder failed: %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 grouped rows, got %d", count)
		}
	})
}

func TestContextChained(t *testing.T) {
	t.Run("get with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "test"})

		ctx := t.Context()
		rows, err := core.NewBuilder(db).
			Table("users").
			Context(ctx).
			Get()
		if err != nil {
			t.Fatalf("get with context failed: %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 1 {
			t.Errorf("expected 1 row, got %d", count)
		}
	})

	t.Run("insert with context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		ctx := t.Context()
		id, err := core.NewBuilder(db).
			Table("users").
			Context(ctx).
			Insert(map[string]any{"name": "contextuser"})
		if err != nil {
			t.Fatalf("insert with context failed: %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})
}

func TestHaving(t *testing.T) {
	t.Run("having builder state", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").Having("SUM(amount) > ?", 100)
		if len(builder.HavingList) != 1 {
			t.Errorf("expected 1 having condition, got %d", len(builder.HavingList))
		}
		if builder.HavingList[0].Operator != "AND" {
			t.Errorf("expected AND operator, got %s", builder.HavingList[0].Operator)
		}
		if len(builder.HavingArgs) != 1 || builder.HavingArgs[0] != 100 {
			t.Error("expected having args [100]")
		}
	})

	t.Run("having eq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingEq("COUNT(*)", 2)
		if len(builder.HavingList) != 1 {
			t.Errorf("expected 1 having condition, got %d", len(builder.HavingList))
		}
		if builder.HavingList[0].Condition != "COUNT(*) = ?" {
			t.Errorf("unexpected condition: %s", builder.HavingList[0].Condition)
		}
	})

	t.Run("having not eq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingNotEq("COUNT(*)", 1)
		if len(builder.HavingList) != 1 {
			t.Errorf("expected 1 having condition, got %d", len(builder.HavingList))
		}
		if builder.HavingList[0].Condition != "COUNT(*) != ?" {
			t.Errorf("unexpected condition: %s", builder.HavingList[0].Condition)
		}
	})

	t.Run("having gt lt ge le", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingGt("SUM(amount)", 150)
		if builder.HavingList[0].Condition != "SUM(amount) > ?" {
			t.Errorf("unexpected gt condition: %s", builder.HavingList[0].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingLt("SUM(amount)", 250)
		if builder.HavingList[0].Condition != "SUM(amount) < ?" {
			t.Errorf("unexpected lt condition: %s", builder.HavingList[0].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingGe("SUM(amount)", 200)
		if builder.HavingList[0].Condition != "SUM(amount) >= ?" {
			t.Errorf("unexpected ge condition: %s", builder.HavingList[0].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingLe("SUM(amount)", 200)
		if builder.HavingList[0].Condition != "SUM(amount) <= ?" {
			t.Errorf("unexpected le condition: %s", builder.HavingList[0].Condition)
		}
	})

	t.Run("having in", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingIn("COUNT(*)", []any{1, 2})
		if len(builder.HavingList) != 1 {
			t.Errorf("expected 1 having condition, got %d", len(builder.HavingList))
		}
		if builder.HavingList[0].Condition != "COUNT(*) IN (?, ?)" {
			t.Errorf("unexpected condition: %s", builder.HavingList[0].Condition)
		}
		if len(builder.HavingArgs) != 2 {
			t.Errorf("expected 2 args, got %d", len(builder.HavingArgs))
		}
	})

	t.Run("having in empty", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingIn("cnt", []any{})
		if len(builder.HavingList) != 0 {
			t.Error("expected empty havingList for empty values")
		}
	})

	t.Run("having not in", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingNotIn("COUNT(*)", []any{2})
		if len(builder.HavingList) != 1 {
			t.Errorf("expected 1 having condition, got %d", len(builder.HavingList))
		}
		if builder.HavingList[0].Condition != "COUNT(*) NOT IN (?)" {
			t.Errorf("unexpected condition: %s", builder.HavingList[0].Condition)
		}
	})

	t.Run("having not in empty", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingNotIn("cnt", []any{})
		if len(builder.HavingList) != 0 {
			t.Error("expected empty havingList for empty values")
		}
	})

	t.Run("having null and not null", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingNull("MAX(note)")
		if builder.HavingList[0].Condition != "MAX(note) IS NULL" {
			t.Errorf("unexpected null condition: %s", builder.HavingList[0].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingNotNull("MAX(note)")
		if builder.HavingList[0].Condition != "MAX(note) IS NOT NULL" {
			t.Errorf("unexpected not null condition: %s", builder.HavingList[0].Condition)
		}
	})

	t.Run("having between", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingBetween("SUM(amount)", 100, 200)
		if builder.HavingList[0].Condition != "SUM(amount) BETWEEN ? AND ?" {
			t.Errorf("unexpected between condition: %s", builder.HavingList[0].Condition)
		}
		if len(builder.HavingArgs) != 2 {
			t.Errorf("expected 2 args, got %d", len(builder.HavingArgs))
		}
	})

	t.Run("having with actual query", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("orders").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "category", Type: "TEXT"},
			core.Column{Name: "amount", Type: "INTEGER"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 100})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 200})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "B", "amount": 50})

		rows, err := core.NewBuilder(db).
			Table("orders").
			Select("category").
			GroupBy("category").
			Having("SUM(amount) > ?", 100).
			Get()
		if err != nil {
			t.Fatalf("having query failed: %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 1 {
			t.Errorf("expected 1 row with sum > 100, got %d", count)
		}
	})
}

func TestOrHaving(t *testing.T) {
	t.Run("or having builder state", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			Having("SUM(amount) < ?", 100).
			OrHaving("SUM(amount) > ?", 200)
		if len(builder.HavingList) != 2 {
			t.Errorf("expected 2 having conditions, got %d", len(builder.HavingList))
		}
		if builder.HavingList[1].Operator != "OR" {
			t.Errorf("expected OR operator, got %s", builder.HavingList[1].Operator)
		}
	})

	t.Run("or having eq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 1).
			OrHavingEq("COUNT(*)", 3)
		if len(builder.HavingList) != 2 {
			t.Errorf("expected 2 having conditions, got %d", len(builder.HavingList))
		}
		if builder.HavingList[1].Condition != "COUNT(*) = ?" {
			t.Errorf("unexpected condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having not eq", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 1).
			OrHavingNotEq("COUNT(*)", 2)
		if builder.HavingList[1].Condition != "COUNT(*) != ?" {
			t.Errorf("unexpected condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having gt lt ge le", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").HavingEq("x", 1).OrHavingGt("SUM(amount)", 250)
		if builder.HavingList[1].Condition != "SUM(amount) > ?" {
			t.Errorf("unexpected gt condition: %s", builder.HavingList[1].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingEq("x", 1).OrHavingLt("SUM(amount)", 50)
		if builder.HavingList[1].Condition != "SUM(amount) < ?" {
			t.Errorf("unexpected lt condition: %s", builder.HavingList[1].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingEq("x", 1).OrHavingGe("SUM(amount)", 300)
		if builder.HavingList[1].Condition != "SUM(amount) >= ?" {
			t.Errorf("unexpected ge condition: %s", builder.HavingList[1].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").HavingEq("x", 1).OrHavingLe("SUM(amount)", 100)
		if builder.HavingList[1].Condition != "SUM(amount) <= ?" {
			t.Errorf("unexpected le condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having in", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 99).
			OrHavingIn("COUNT(*)", []any{1, 3})
		if len(builder.HavingList) != 2 {
			t.Errorf("expected 2 having conditions, got %d", len(builder.HavingList))
		}
		if builder.HavingList[1].Condition != "COUNT(*) IN (?, ?)" {
			t.Errorf("unexpected condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having in empty", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").OrHavingIn("cnt", []any{})
		if len(builder.HavingList) != 0 {
			t.Error("expected empty havingList for empty values")
		}
	})

	t.Run("or having not in", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 99).
			OrHavingNotIn("COUNT(*)", []any{2})
		if builder.HavingList[1].Condition != "COUNT(*) NOT IN (?)" {
			t.Errorf("unexpected condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having not in empty", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").OrHavingNotIn("cnt", []any{})
		if len(builder.HavingList) != 0 {
			t.Error("expected empty havingList for empty values")
		}
	})

	t.Run("or having null and not null", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 99).
			OrHavingNull("MAX(note)")
		if builder.HavingList[1].Condition != "MAX(note) IS NULL" {
			t.Errorf("unexpected null condition: %s", builder.HavingList[1].Condition)
		}

		builder = core.NewBuilder(db).Table("orders").
			HavingEq("COUNT(*)", 99).
			OrHavingNotNull("MAX(note)")
		if builder.HavingList[1].Condition != "MAX(note) IS NOT NULL" {
			t.Errorf("unexpected not null condition: %s", builder.HavingList[1].Condition)
		}
	})

	t.Run("or having between", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		builder := core.NewBuilder(db).Table("orders").
			HavingEq("SUM(amount)", 50).
			OrHavingBetween("SUM(amount)", 200, 300)
		if builder.HavingList[1].Condition != "SUM(amount) BETWEEN ? AND ?" {
			t.Errorf("unexpected between condition: %s", builder.HavingList[1].Condition)
		}
		if len(builder.HavingArgs) != 3 {
			t.Errorf("expected 3 args, got %d", len(builder.HavingArgs))
		}
	})

	t.Run("or having with actual query", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("orders").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "category", Type: "TEXT"},
			core.Column{Name: "amount", Type: "INTEGER"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "A", "amount": 50})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "B", "amount": 150})
		core.NewBuilder(db).Table("orders").Insert(map[string]any{"category": "C", "amount": 300})

		rows, err := core.NewBuilder(db).
			Table("orders").
			Select("category").
			GroupBy("category").
			Having("SUM(amount) < ?", 100).
			OrHaving("SUM(amount) > ?", 200).
			Get()
		if err != nil {
			t.Fatalf("or having query failed: %v", err)
		}
		defer rows.Close()

		count := 0
		for rows.Next() {
			count++
		}
		if count != 2 {
			t.Errorf("expected 2 categories (sum<100 OR sum>200), got %d", count)
		}
	})
}

func TestGetWithTotal(t *testing.T) {
	t.Run("get with total", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		for i := 0; i < 10; i++ {
			core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user"})
		}

		rows, err := core.NewBuilder(db).
			Table("users").
			Limit(3).
			GetWithTotal()
		if err != nil {
			t.Fatalf("get with total failed: %v", err)
		}
		defer rows.Close()

		rowCount := 0
		var total int
		for rows.Next() {
			var id int
			var name string
			rows.Scan(&total, &id, &name)
			rowCount++
		}
		if rowCount != 3 {
			t.Errorf("expected 3 rows, got %d", rowCount)
		}
		if total != 10 {
			t.Errorf("expected total 10, got %d", total)
		}
	})

	t.Run("get with total error no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).GetWithTotal()
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestGetWithTotalContext(t *testing.T) {
	t.Run("get with total context", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		for i := 0; i < 5; i++ {
			core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user"})
		}

		ctx := t.Context()
		rows, err := core.NewBuilder(db).
			Table("users").
			Limit(2).
			GetWithTotalContext(ctx)
		if err != nil {
			t.Fatalf("get with total context failed: %v", err)
		}
		defer rows.Close()

		rowCount := 0
		var total int
		for rows.Next() {
			var id int
			var name string
			rows.Scan(&total, &id, &name)
			rowCount++
		}
		if rowCount != 2 {
			t.Errorf("expected 2 rows, got %d", rowCount)
		}
		if total != 5 {
			t.Errorf("expected total 5, got %d", total)
		}
	})

	t.Run("get with total context error no table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		ctx := t.Context()
		_, err := core.NewBuilder(db).GetWithTotalContext(ctx)
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})
}

func TestGetWithTotalWithContext(t *testing.T) {
	t.Run("get with total using context method", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		for i := 0; i < 8; i++ {
			core.NewBuilder(db).Table("users").Insert(map[string]any{"name": "user"})
		}

		ctx := t.Context()
		rows, err := core.NewBuilder(db).
			Table("users").
			Context(ctx).
			Limit(2).
			GetWithTotal()
		if err != nil {
			t.Fatalf("get with total using context failed: %v", err)
		}
		defer rows.Close()

		rowCount := 0
		var total int
		for rows.Next() {
			var id int
			var name string
			rows.Scan(&total, &id, &name)
			rowCount++
		}
		if rowCount != 2 {
			t.Errorf("expected 2 rows, got %d", rowCount)
		}
		if total != 8 {
			t.Errorf("expected total 8, got %d", total)
		}
	})
}

func TestInsertBatch(t *testing.T) {
	t.Run("batch insert multiple rows", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
			core.Column{Name: "name", Type: "TEXT"},
			core.Column{Name: "age", Type: "INTEGER"},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		data := []map[string]any{
			{"name": "Alice", "age": 25},
			{"name": "Bob", "age": 30},
			{"name": "Charlie", "age": 35},
		}

		rowsAffected, err := core.NewBuilder(db).Table("users").InsertBatch(data)
		if err != nil {
			t.Fatalf("InsertBatch failed: %v", err)
		}
		if rowsAffected != 3 {
			t.Errorf("expected 3 rows affected, got %d", rowsAffected)
		}

		rows, err := core.NewBuilder(db).Table("users").Select("name", "age").Get()
		if err != nil {
			t.Fatalf("failed to query: %v", err)
		}
		defer rows.Close()

		var count int
		for rows.Next() {
			count++
		}
		if count != 3 {
			t.Errorf("expected 3 rows, got %d", count)
		}
	})

	t.Run("batch insert empty data", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").InsertBatch([]map[string]any{})
		if err == nil {
			t.Fatal("expected error for empty batch data")
		}
	})

	t.Run("batch insert without table", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).InsertBatch([]map[string]any{
			{"name": "Test"},
		})
		if err == nil {
			t.Fatal("expected error for missing table")
		}
	})

	t.Run("batch insert with invalid column name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).Table("users").InsertBatch([]map[string]any{
			{"invalid;column": "value"},
		})
		if err == nil {
			t.Fatal("expected error for invalid column name")
		}
	})

	t.Run("batch insert with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		_, err := core.NewBuilder(db).Table("invalid;table").InsertBatch([]map[string]any{
			{"name": "Test"},
		})
		if err == nil {
			t.Fatal("expected error for invalid table name")
		}
	})
}

func TestDeleteUnsupportedClauses(t *testing.T) {
	t.Run("delete with JOIN", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Join("orders", "users.id = orders.user_id").
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support JOIN" {
			t.Fatalf("expected JOIN error, got: %v", err)
		}
	})

	t.Run("delete with GROUP BY", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			GroupBy("id").
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support GROUP BY" {
			t.Fatalf("expected GROUP BY error, got: %v", err)
		}
	})

	t.Run("delete with HAVING", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			HavingEq("id", 1).
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support HAVING" {
			t.Fatalf("expected HAVING error, got: %v", err)
		}
	})

	t.Run("delete with ORDER BY", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			OrderBy("id").
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support ORDER BY" {
			t.Fatalf("expected ORDER BY error, got: %v", err)
		}
	})

	t.Run("delete with LIMIT", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Limit(10).
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support LIMIT / OFFSET" {
			t.Fatalf("expected LIMIT error, got: %v", err)
		}
	})

	t.Run("delete with OFFSET", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Offset(5).
			WhereEq("id", 1).
			Delete()
		if err == nil || err.Error() != "SQLite DELETE does not support LIMIT / OFFSET" {
			t.Fatalf("expected OFFSET error, got: %v", err)
		}
	})
}

func TestValidateColumnMaxLength(t *testing.T) {
	t.Run("column name exceeds max length", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		longName := "a"
		for i := 0; i < 130; i++ {
			longName += "a"
		}

		_, err = core.NewBuilder(db).Table("users").Insert(map[string]any{
			longName: "value",
		})
		if err == nil {
			t.Fatal("expected error for column name exceeding max length")
		}
	})
}

func TestBuildJoinErrors(t *testing.T) {
	t.Run("join with invalid table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Join("invalid;table", "users.id = invalid;table.id").
			Get()
		if err == nil {
			t.Fatal("expected error for invalid join table name")
		}
	})

	t.Run("join with empty on clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Join("orders", "").
			Get()
		if err == nil {
			t.Fatal("expected error for empty join ON clause")
		}
	})

	t.Run("join with whitespace only on clause", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := core.NewBuilder(db).Table("users").Create(
			core.Column{Name: "id", Type: "INTEGER", IsPrimary: true},
		)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		_, err = core.NewBuilder(db).
			Table("users").
			Join("orders", "   ").
			Get()
		if err == nil {
			t.Fatal("expected error for whitespace-only join ON clause")
		}
	})
}
