// * generated by claude sonnet 4.5
package goSqlite

import (
	"database/sql"
	"os"
	"path/filepath"
	"testing"
)

func setupTestDB(t *testing.T) (*Database, *sql.DB, string) {
	t.Helper()

	dbPath := filepath.Join(t.TempDir(), "test.db")
	database, db, err := New(Config{
		Key:      "test_" + t.Name(),
		Path:     dbPath,
		Lifetime: 30,
	})
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}

	return database, db, dbPath
}

func TestNew(t *testing.T) {
	t.Run("create new database", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "test.db")
		database, db, err := New(Config{
			Key:      "test_new",
			Path:     dbPath,
			Lifetime: 30,
		})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if database == nil {
			t.Fatal("expected database instance, got nil")
		}
		if db == nil {
			t.Fatal("expected db instance, got nil")
		}
		defer database.Close()

		if _, err := os.Stat(dbPath); os.IsNotExist(err) {
			t.Fatalf("database file not created at %s", dbPath)
		}
	})

	t.Run("reuse existing database connection", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "test.db")
		config := Config{
			Key:      "test_reuse",
			Path:     dbPath,
			Lifetime: 30,
		}

		database1, db1, err := New(config)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer database1.Close()

		_, db2, err := New(config)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		if db1 != db2 {
			t.Error("expected same db instance for same key")
		}
	})

	t.Run("auto generate key from path", func(t *testing.T) {
		dbPath := filepath.Join(t.TempDir(), "mydb.db")
		database, db, err := New(Config{
			Path:     dbPath,
			Lifetime: 30,
		})
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer database.Close()

		if db == nil {
			t.Fatal("expected db instance, got nil")
		}
	})

	t.Run("invalid path", func(t *testing.T) {
		database, db, err := New(Config{
			Key:  "test_invalid",
			Path: "/invalid/path/db.db",
		})
		if err == nil {
			if database != nil {
				database.Close()
			}
			t.Fatal("expected error for invalid path")
		}
		if db != nil {
			t.Error("expected nil db on error")
		}
	})
}

func TestDatabaseClose(t *testing.T) {
	t.Run("close database successfully", func(t *testing.T) {
		database, _, _ := setupTestDB(t)
		database.Close()

		if database.db != nil {
			t.Error("expected db map to be nil after close")
		}
	})

	t.Run("close multiple databases", func(t *testing.T) {
		dbPath1 := filepath.Join(t.TempDir(), "test1.db")
		dbPath2 := filepath.Join(t.TempDir(), "test2.db")

		database, _, err := New(Config{Key: "db1", Path: dbPath1})
		if err != nil {
			t.Fatalf("failed to create db1: %v", err)
		}

		_, _, err = New(Config{Key: "db2", Path: dbPath2})
		if err != nil {
			t.Fatalf("failed to create db2: %v", err)
		}

		database.Close()

		if database.db != nil {
			t.Error("expected db map to be nil after close")
		}
	})
}

func TestBuilderCreate(t *testing.T) {
	t.Run("create table with basic columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("users").
			Create(
				Column{
					Name:         "id",
					Type:         "INTEGER",
					IsPrimary:    true,
					AutoIncrease: true,
				},
				Column{
					Name:       "name",
					Type:       "TEXT",
					IsNullable: false,
				},
			)

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		var tableName string
		err = db.QueryRow("SELECT name FROM sqlite_master WHERE type='table' AND name='users'").Scan(&tableName)
		if err != nil {
			t.Fatalf("table not created: %v", err)
		}
		if tableName != "users" {
			t.Errorf("expected table name 'users', got %s", tableName)
		}
	})

	t.Run("create table with all column types", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("products").
			Create(
				Column{
					Name:         "id",
					Type:         "INTEGER",
					IsPrimary:    true,
					AutoIncrease: true,
				},
				Column{
					Name:       "name",
					Type:       "TEXT",
					IsNullable: false,
					IsUnique:   true,
				},
				Column{
					Name:    "price",
					Type:    "REAL",
					Default: 0.0,
				},
				Column{
					Name:       "description",
					Type:       "TEXT",
					IsNullable: true,
				},
			)

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
	})

	t.Run("create table without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Create(
				Column{Name: "id", Type: "INTEGER"},
			)

		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("create table without columns", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("empty").
			Create()

		if err == nil {
			t.Fatal("expected error for empty columns")
		}
	})
}

func TestBuilderInsert(t *testing.T) {
	t.Run("insert single row", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("users").
			Create(
				Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				Column{Name: "name", Type: "TEXT", IsNullable: false},
				Column{Name: "email", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		err = NewBuilder(db).
			Table("users").
			Insert(map[string]any{
				"name":  "test",
				"email": "test@example.com",
			})

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		var count int
		err = db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count)
		if err != nil {
			t.Fatalf("failed to count rows: %v", err)
		}
		if count != 1 {
			t.Errorf("expected 1 row, got %d", count)
		}
	})

	t.Run("insert without table name", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Insert(map[string]any{"name": "test"})

		if err == nil {
			t.Fatal("expected error for missing table name")
		}
	})

	t.Run("insert with empty data", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("users").
			Insert(map[string]any{})

		if err == nil {
			t.Fatal("expected error for empty data")
		}
	})
}

func TestBuilderInsertReturningID(t *testing.T) {
	t.Run("insert and return id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("users").
			Create(
				Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				Column{Name: "name", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		id, err := NewBuilder(db).
			Table("users").
			InsertReturningID(map[string]any{
				"name": "test",
			})

		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if id != 1 {
			t.Errorf("expected id 1, got %d", id)
		}
	})

	t.Run("insert multiple rows and check incrementing id", func(t *testing.T) {
		database, db, _ := setupTestDB(t)
		defer database.Close()

		err := NewBuilder(db).
			Table("users").
			Create(
				Column{Name: "id", Type: "INTEGER", IsPrimary: true, AutoIncrease: true},
				Column{Name: "name", Type: "TEXT", IsNullable: false},
			)
		if err != nil {
			t.Fatalf("failed to create table: %v", err)
		}

		id1, _ := NewBuilder(db).Table("users").InsertReturningID(map[string]any{"name": "user1"})
		id2, _ := NewBuilder(db).Table("users").InsertReturningID(map[string]any{"name": "user2"})

		if id2 != id1+1 {
			t.Errorf("expected id2 to be %d, got %d", id1+1, id2)
		}
	})
}
